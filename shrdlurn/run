#!/usr/bin/ruby

# This is the main entry point for running SHRDLURN.  See
# fig/lib/execrunner.rb for more documentation for how commands are generated.
# There are a bunch of modes that this script can be invoked with, which
# loosely correspond to the modules.

$: << 'fig/lib'
require 'execrunner'

$modes = []
def addMode(name, description, func)
  $modes << [name, description, func]
end

def codalab(dependencies=nil)
  # Set @cl=1 to run job on CodaLab
  dependencies ||= l(':fig', ':lib', ':module-classes.txt', ':libsempre')
  l(
    letDefault(:cl, 0),
    sel(:cl,
      l(),
      l('cl', 'run', dependencies, '---', 'LC_ALL=C.UTF-8'),
    nil),
  nil)
end

def header(modules='core', codalabDependencies=nil)
  l(
    codalab(codalabDependencies),
    # Queuing system
    letDefault(:q, 0), sel(:q, l(), l('fig/bin/q', '-shareWorkingPath', o('mem', '5g'), o('memGrace', 10), '-add', '---')),
    # Create execution directory
    letDefault(:pooldir, 1),
    sel(:pooldir, l(), 'fig/bin/qcreate'),
    # Run the Java command...
    'java',
    '-ea',
    '-Dmodules='+modules,
    # Memory size
    letDefault(:memsize, 'default'),
    sel(:memsize, {
      'tiny' => l('-Xms2G', '-Xmx4G'),
      'low' => l('-Xms5G', '-Xmx7G'),
      'default' => l('-Xms8G', '-Xmx10G'),
      'medium' => l('-Xms12G', '-Xmx14G'),
      'high' => l('-Xms20G', '-Xmx24G'),
      'higher' => l('-Xms40G', '-Xmx50G'),
      'impressive' => l('-Xms75G', '-Xmx90G'),
    }),
    # Classpath
    '-cp', 'libsempre/*:lib/*',
    # Profiling
    letDefault(:prof, 0), sel(:prof, l(), '-Xrunhprof:cpu=samples,depth=100,file=_OUTPATH_/java.hprof.txt'),
    # Debugging
    letDefault(:debug, 0), sel(:debug, l(), l('-Xdebug', '-Xrunjdwp:server=y,transport=dt_socket,suspend=y,address=8898')),
  nil)
end

def figOpts; l(selo(:pooldir, 'execDir', 'exec', '_OUTPATH_'), o('overwriteExecDir'), o('addToView', 0)) end

############################################################
# Unit tests

addMode('backup', 'small commands like run community server, backup, or simulator', lambda { |e| l(
  lambda { |e| system 'echo "backing up with mv"'},
  lambda { |e| system 'mkdir -p ./int-backup/'},
	letDefault(:msg, 'backing up, no message'),
	lambda { |e| l('echo ', :msg, '> ./int-backup/message')},
	lambda { |e| l('echo ', '`date +%Y-%m-%d.%H:%M:%S`', '>> ./int-backup/message')},
  lambda { |e| system 'mv int-output int-backup/`date +%Y-%m-%d.%H:%M:%S`'},
  lambda { |e| system 'mkdir -p ./int-output'},
nil)})

addMode('backup-data', 'put community-server into trash with time stamp', lambda { |e| l(
	lambda { |e| system 'echo "backing up data with mv"'},
  lambda { |e| system 'mkdir -p ./community-server/data-backup'},
  lambda { |e| system 'mv ./community-server/data ./community-server/data-backup/`date +%Y-%m-%d.%H:%M:%S`'},
nil)})

addMode('trash', 'put int-output into trash with time stamp', lambda { |e| l(
  lambda { |e| system 'echo "trashing int-output with time stamp"'},
	lambda { |e| system 'mv int-output int-output-trash-`date +%Y-%m-%d.%H:%M:%S`'},
  lambda { |e| system 'rm -rf int-output-trash-*'},
  lambda { |e| system 'mkdir -p ./int-output'},
nil)})

addMode('test', 'Run unit tests for interactive stuff', lambda { |e|
  l(
    'java', '-ea', '-Xmx12g', '-cp', 'libsempre/*:lib/*',
    letDefault(:debug, 0), sel(:debug, l(), l('-Xdebug', '-Xrunjdwp:server=y,transport=dt_socket,suspend=y,address=8898')),
    'org.testng.TestNG',
    lambda { |e|
      if e[:class]
        l('-testclass', 'edu.stanford.nlp.sempre.interactive.test.' + e[:class])
      else
        'shrdlurn/testng.xml'
      end
    },
  nil)
})

addMode('community-dep', 'dependencies for the community server', lambda { |e| l(
l('python ./community-server/install-deps.py'),
nil)})

addMode('community', 'start the community server', lambda { |e| l(
l('python community-server/server.py -- port 8403'),
nil)})

addMode('simulator', 'run the simulator', lambda { |e| l(
	# rlwrap,
	header('core,interactive'),
	'edu.stanford.nlp.sempre.interactive.Simulator',
	figOpts,
	letDefault(:server, 'local'),
	sel(:server, {
		'local' => o('serverURL', 'http://localhost:8410'),
		'remote' => o('serverURL', 'http://jonsson.stanford.edu:8410')
	}),
	# set to 0 to enable logging
	o('numThreads', 1),
	letDefault(:sandbox, 'full'),
	sel(:sandbox, {
		'all' => o('reqParams', 'grammar=0\&cite=0\&learn=0\&logging=0'),
		'nolog' => o('reqParams', 'grammar=0\&cite=0\&learn=1\&logging=0'),
		'nolearn' => o('reqParams', 'grammar=1\&cite=1\&learn=0\&logging=0'),
		'none' => o('reqParams', 'grammar=1\&cite=1\&learn=1\&logging=0'),
		'nocite' => o('reqParams', 'grammar=1\&cite=0\&learn=1\&logging=0'),
	}),
	letDefault(:task, 'sidaw'),
	sel(:task, {
		'freebig' => o('logFiles', './shrdlurn/queries/freebuildbig-0206.json.gz'),
		'freebigcontext' => o('logFiles', './shrdlurn/queries/freebuildbig-0206.context.json.gz'),

		'qual1' => o('logFiles', './shrdlurn/queries/qualifier1-0118.json.gz'),
		'qual2' => o('logFiles', './shrdlurn/queries/qualifier2-0129.json.gz'),
		'qual3' => o('logFiles', './shrdlurn/queries/qualifier3-0201.json.gz'), #  both 2 and 3
		'free1' => o('logFiles', './shrdlurn/queries/freebuild1-0121.json.gz'),
		'free2' => o('logFiles', './shrdlurn/queries/freebuild2-0127.json.gz'),
		'sidaw' => o('logFiles', './shrdlurn/queries/sidaw.json'),
		}),
nil)})

############################################################
# {2016-07-02} [Sida Wang]: interactive semantic parsing
addMode('interactive', 'interactive semantic parsing in a VoxelWorld', lambda { |e| l(
  #rlwrap,
  header('core,interactive'),
  'edu.stanford.nlp.sempre.Main',
  #figOpts,

  o('Executor', 'interactive.ActionExecutor'),
  o('LanguageAnalyzer', 'interactive.ActionLanguageAnalyzer'),
  o('ActionExecutor.convertNumberValues', true),
  o('ActionExecutor.printStackTrace', true),
  o('VoxelWorld.maxBlocks', 3000),
  selo(0, 'ActionExecutor.FlatWorldType', 'BlocksWorld', 'CalendarWorld'),
  selo(0, 'Grammar.inPaths', './shrdlurn/blocksworld.grammar', './shrdlurn/calendar.grammar'),

  o('Params.initWeightsRandomly', false),
  o('Grammar.binarizeRules', false),
  o('Grammar.useApplyFn', 'interactive.ApplyFn'),

  o('LanguageAnalyzer.lowerCaseTokens', true),

  o('Parser.pruneErrorValues', true),
  o('Parser', 'BeamFloatingParser'),
  o('FloatingParser.defaultIsFloating', true),

  selo(0, 'BeamFloatingParser.floatStrategy', 'Never', 'NoParse', 'Always'),
	o('BeamFloatingParser.trackedCats', 'Number', 'Numbers', 'Color',  'Direction', 'Set', 'Sets', 'Action', 'Actions'),

	o('ParserState.customExpectedCounts', 'None'),
	o('Params.l1Reg', 'nonlazy'),
	o('Params.l1RegCoeff', 0.0001),
	o('Parser.beamSize', 25),
	o('Params.initStepSize', 0.1),
	o('Params.adaptiveStepSize', true),
	#o('Params.stepSizeReduction', 0.25),

	o('FeatureExtractor.featureComputers', 'interactive.ActionFeatureComputer'),
	o('FeatureExtractor.featureDomains', ':rule', ':span', ':stats', ':scope', ':social', ':window'),
	# o('FeatureExtractor.featureDomains', ':rule'),

	o('Master.intOutputPath', './int-output/'),
	o('ILUtils.citationPath', './int-output/citation/'),

	o('ILUtils.useAligner', true),
	o('ILUtils.maxSequence', 20),

	o('DefinitionAligner.strategies', 'ExactExclusion'),

	o('Master.onlineLearnExamples', true),
	o('Master.independentSessions', false),

	o('Master.onlyInteractive', true),

	o('jsonServer', true),

	o('JsonServer.numThreads', 16),
	o('JsonServer.maxCandidates', 50),
	o('JsonServer.queryLogPath', './int-output/query.log'),
	o('JsonServer.responseLogPath', './int-output/response.log'),
	o('JsonServer.port', 8410),

	o('GrammarInducer.useBestPacking', true),
	o('GrammarInducer.useSimplePacking', true),

	o('Derivation.showTypes', false),
	o('Derivation.showValues', false),
	o('Derivation.showRules', false),

	lambda { |e| system 'mkdir -p ./int-output/'; nil},
	lambda { |e| system 'mkdir -p ./int-output/log/'; nil},
	lambda { |e| system 'mkdir -p ./int-output/citation/'; nil},
	lambda { |e| system 'mkdir -p server.exec';
		l(o('execDir', 'server.exec/'),
		o('overwriteExecDir'))
	 },
nil) })
############################################################

if ARGV.size == 0
  puts "#{$0} @mode=<mode> [options]"
  puts
  puts 'This is the main entry point for all SHRDLRUN related runs.'
  puts "Modes:"
  $modes.each { |name,description,func|
    puts "  #{name}: #{description}"
  }
end

modesMap = {}
$modes.each { |name,description,func|
  modesMap[name] = func
}
run!(sel(:mode, modesMap))
