# Jonathan Berant's solution to the tutorial.

#lexicon
(rule $Binary (area) (ConstantFn fb:location.location.area (-> fb:type.any fb:type.any)))
(rule $Unary (city) (ConstantFn (fb:type.object.type fb:location.citytown) fb:location.citytown))
(rule $Unary (cities) (ConstantFn (fb:type.object.type fb:location.citytown) fb:location.citytown))
(rule $Superlative (with the largest) (ConstantFn (lambda x (lambda y (argmax 1 1 (var y) (var x))))))
(rule $TOP5 (top 5) (ConstantFn (lambda x (lambda y (argmax 1 5 (var x) (var y))))))
(rule $RANK2 (second) (ConstantFn (lambda y (lambda x (argmax 2 1 (var x) (var y)))) (-> (-> fb:type.any fb:type.any) (-> fb:type.any fb:type.any))))
(rule $Unary (countries) (ConstantFn (fb:type.object.type fb:location.country) fb:location.country))
(rule $Unary (country) (ConstantFn (fb:type.object.type fb:location.country) fb:location.country))
(rule $Unit (squared kilometers) (IdentityFn))
(rule $Larger (at least) (ConstantFn (lambda x (>= (var x)))))
(rule $Binary (capital) (ConstantFn fb:location.country.capital (-> fb:type.any fb:type.any)))
(rule $Unary (states) (ConstantFn (fb:type.object.type fb:location.us_state) fb:location.us_state))
(rule $Binary (bordering) (ConstantFn (lambda x (fb:location.location.adjoin_s (fb:location.adjoining_relationship.adjoins (var x)))) (-> fb:type.any fb:type.any)))
(rule $Entity (oregon) (ConstantFn fb:en.oregon fb:type.any))
(rule $Entity (washington) (ConstantFn fb:en.washington fb:type.any))
(rule $Conjunction (and) (ConstantFn (lambda x (lambda y (lambda z (and ((var z) (var x)) ((var z) (var y)))))) (-> fb:type.any (-> fb:type.any (-> (-> fb:type.any fb:type.any) fb:type.any)))))
(rule $Binary (tallest) (ConstantFn fb:geography.mountain.elevation (-> fb:type.any fb:type.any)))
(rule $Unary (mountain) (ConstantFn (fb:type.object.type fb:geography.mountain) fb:geography.mountain))
(rule $Binary (in) (ConstantFn fb:location.location.containedby (-> fb:type.any fb:type.any)))
(rule $Unary (france) (ConstantFn fb:en.france fb:type.any))
#question 1
(rule $SuperBinary ($Superlative $Binary) (JoinFn forward betaReduce))
(rule $SuperBinaryUnary ($Unary $SuperBinary) (JoinFn backward betaReduce))
(rule $ROOT ($SuperBinaryUnary) (IdentityFn))
#question 2
(rule $Number ($TOKEN) (NumberFn))
(rule $SuperUnary ($TOP5 $Unary) (JoinFn forward betaReduce))
(rule $SuperBinaryUnary ($SuperUnary by $Binary) (JoinFn forward betaReduce))
#question 3
(rule $LargerNumber ($Larger $Number) (JoinFn forward betaReduce))
(rule $LargerNumber ($LargerNumber $Unit) (IdentityFn))
(rule $Set ($Binary $LargerNumber) (JoinFn forward))
(rule $Set ($Unary whose $Set) (MergeFn and))
#question 4
(rule $ConjunctionEntity ($Conjunction $Entity) (JoinFn forward betaReduce))
(rule $ConjunctionEntityEntity ($Entity $ConjunctionEntity) (JoinFn backward betaReduce))
(rule $Set ($Binary $ConjunctionEntityEntity) (JoinFn backward betaReduce))
#question 5
(rule $Superlative ($RANK2) (IdentityFn))
(rule $SuperBinaryUnary ($SuperBinary $Set) (JoinFn forward betaReduce))
#question 6 - skipping this

#General
(rule $Set ($Binary $Set) (JoinFn forward))
(rule $Set ($Unary) (IdentityFn))
(rule $Set ($Unary $Set) (MergeFn and))
(rule $ROOT ($Set) (IdentityFn))
